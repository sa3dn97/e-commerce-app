{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://ngx-bootstrap/carousel/carousel.config.ts","ng://ngx-bootstrap/carousel/carousel.component.html","ng://ngx-bootstrap/carousel/carousel.component.ts","ng://ngx-bootstrap/carousel/utils.ts","ng://ngx-bootstrap/carousel/slide.component.ts","ng://ngx-bootstrap/carousel/carousel.module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","__spread","arguments","length","concat","CarouselConfig","this","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","t","i0.ɵɵelementStart","i0.ɵɵlistener","i0.ɵɵelementEnd","i0.ɵɵclassProp","i0.ɵɵtemplate","i0.ɵɵadvance","i0.ɵɵproperty","i0.ɵɵtext","i0.ɵɵelement","Direction","CarouselComponent","config","ngZone","isAnimated","activeSlideChange","EventEmitter","slideRangeChange","startFromIndex","_slides","LinkedList","_currentVisibleSlidesIndex","destroyed","getActive","slide","active","makeSlidesConsistent","slides","forEach","index","item","order","Object","assign","defineProperty","prototype","_currentActiveSlide","multilist","_select","_interval","restartTimer","toArray","isBs3","ngAfterViewInit","_this","setTimeout","_chunkedSlides","array","size","out","Math","ceil","chunk","splice","chunkByNumber","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","activeSlide","play","removeSlide","remIndex","indexOf","nextSlideIndex_1","isLast","remove","currentSlideIndex_1","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","nextSlide","isPlaying","previousSlide","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","predicate","l","findLastIndex","direction","firstVisibleIndex","lastVisibleIndex","moveMultilist","findNextSlideIndex","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlide","selectSlideRange","pause","isFirst","indicatorsSlides","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","getVisibleIndexes","nextSlideIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","get","slidesToReorder","displayedIndex","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","setInterval","nInterval","run","clearInterval","core","NgZone","selectors","inputs","outputs","ngContentSelectors","_c1","decls","vars","consts","template","rf","ctx","$event","i0.ɵɵprojection","SlideComponent","carousel","itemWidth","addClass","ngOnInit","CarouselModule","forRoot","ngModule","providers","imports","common","CommonModule","declarations","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class CarouselConfig {\n  /* Default interval of auto changing of slides */\n  interval = 5000;\n\n  /* Is loop of auto changing of slides can be paused */\n  noPause = false;\n\n  /* Is slides can wrap from the last to the first slide */\n  noWrap = false;\n\n  /* Show carousel-indicators */\n  showIndicators = true;\n\n  /* Slides can be paused on focus */\n  pauseOnFocus = false;\n\n  /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n  indicatorsByChunk = false;\n\n  /* If value more then 1 â carousel works in multilist mode */\n  itemsPerSlide = 1;\n\n  /* If `true` â carousel shifts by one element. By default carousel shifts by number\n    of visible elements (itemsPerSlide field) */\n  singleSlideOffset = false;\n}\n","<div (mouseenter)=\"pause()\"\n     (mouseleave)=\"onMouseLeave()\"\n     (mouseup)=\"onMouseUp()\"\n     (keydown)=\"keydownPress($event)\"\n     (focusin)=\"pauseFocusIn()\"\n     (focusout)=\"pauseFocusOut()\"\n     class=\"carousel slide\" tabindex=\"0\">\n  <ol class=\"carousel-indicators\" *ngIf=\"showIndicators && slides.length > 1\">\n    <li *ngFor=\"let slide of indicatorsSlides(); let i = index;\"\n        [class.active]=\"slide.active === true\"\n        (click)=\"selectSlide(i)\">\n    </li>\n  </ol>\n  <div class=\"carousel-inner\" [ngStyle]=\"{'display': multilist ? 'flex' : 'block'}\">\n    <ng-content></ng-content>\n  </div>\n  <a class=\"left carousel-control carousel-control-prev\"\n     [class.disabled]=\"activeSlide === 0 && noWrap\"\n     (click)=\"previousSlide()\" *ngIf=\"slides.length > 1\"\n      tabindex=\"0\" role=\"button\">\n    <span class=\"icon-prev carousel-control-prev-icon\" aria-hidden=\"true\"></span>\n    <span *ngIf=\"isBs4\" class=\"sr-only\">Previous</span>\n  </a>\n  <a class=\"right carousel-control carousel-control-next\"\n     [class.disabled]=\"isLast(activeSlide) && noWrap\"\n     (click)=\"nextSlide()\" *ngIf=\"slides.length > 1\"\n     tabindex=\"0\" role=\"button\">\n    <span class=\"icon-next carousel-control-next-icon\" aria-hidden=\"true\"></span>\n    <span class=\"sr-only\">Next</span>\n  </a>\n</div>\n","// tslint:disable:max-file-line-count\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output, AfterViewInit\n} from '@angular/core';\n\nimport { isBs3, LinkedList } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { findLastIndex, chunkByNumber } from './utils';\nimport { SlideWithIndex, IndexedSlideList } from './models';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements AfterViewInit, OnDestroy {\n  /* If `true` â carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap: boolean;\n  /*  If `true` â will disable pausing on carousel mouse hover */\n  @Input() noPause: boolean;\n  /*  If `true` â carousel-indicators are visible  */\n  @Input() showIndicators: boolean;\n  /*  If `true` - autoplay will be stopped on focus */\n  @Input() pauseOnFocus: boolean;\n  /* If `true` - carousel indicators indicate slides chunks\n     works ONLY if singleSlideOffset = FALSE */\n  @Input() indicatorsByChunk = false;\n  /* If value more then 1 â carousel works in multilist mode */\n  @Input() itemsPerSlide = 1;\n  /* If `true` â carousel shifts by one element. By default carousel shifts by number\n     of visible elements (itemsPerSlide field) */\n  @Input() singleSlideOffset = false;\n  /** Turn on/off animation. Animation doesn't work for multilist carousel */\n  @Input() isAnimated = false;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange: EventEmitter<number> = new EventEmitter<number>(false);\n\n  /** Will be emitted when active slides has been changed in multilist mode */\n  @Output()\n  slideRangeChange: EventEmitter<number[]> = new EventEmitter<number[]>();\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this.multilist) {\n      return;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  /* Index to start display slides from it */\n  @Input()\n  startFromIndex = 0;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  // tslint:disable-next-line:no-any\n  protected currentInterval: any;\n  protected _currentActiveSlide: number;\n  protected _interval: number;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected _chunkedSlides: SlideWithIndex[][];\n  protected _slidesWithIndexes: SlideWithIndex[];\n  protected _currentVisibleSlidesIndex = 0;\n  protected isPlaying: boolean;\n  protected destroyed = false;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n  }\n\n  ngAfterViewInit(): void {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(\n          this.mapSlidesAndIndexes(),\n          this.itemsPerSlide\n        );\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false): void {\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex(): number {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex(): number {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  getActive = (slide: SlideComponent) => slide.active;\n\n  move(direction: Direction, force = false): void {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (\n        direction === Direction.NEXT &&\n        this.isLast(lastVisibleIndex) ||\n        direction === Direction.PREV &&\n        firstVisibleIndex === 0\n      ) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event: KeyboardEvent) {\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n\n      return;\n    }\n  }\n\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn(): void {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut(): void {\n    this.play();\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex(this.getActive);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index: number): boolean {\n    return index === 0;\n  }\n\n  indicatorsSlides(): SlideComponent[] {\n    return this.slides.filter(\n      (slide: SlideComponent, index: number) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0\n    );\n  }\n\n  private selectInitialSlides(): void {\n    const startIndex = this.startFromIndex <= this._slides.length\n      ? this.startFromIndex\n      : 0;\n\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes  = [\n          ...this._slidesWithIndexes,\n          ...slidesToAppend\n        ]\n          .slice(slidesToAppend.length)\n          .slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(\n          startIndex,\n          startIndex + this.itemsPerSlide\n        );\n      }\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide)\n          ? this._currentActiveSlide + 1\n          : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex =\n          this._currentActiveSlide > 0\n            ? this._currentActiveSlide - 1\n            : !force && this.noWrap\n              ? this._currentActiveSlide\n              : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  private mapSlidesAndIndexes(): SlideWithIndex[] {\n    return this.slides\n      .slice()\n      .map((slide: SlideComponent, index: number) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n  }\n\n\n  private selectSlideRange(index: number): void {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index)\n        ? index\n        : index - this.itemsPerSlide + 1;\n\n      const endIndex = this.isIndexOnTheEdges(index)\n        ? index + this.itemsPerSlide\n        : index + 1;\n\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  private selectRangeByNestedIndex(index: number): void {\n    const selectedRange = this._chunkedSlides\n      .map((slidesList, i: number) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      })\n      .find(\n        (slidesList: IndexedSlideList) => {\n          return slidesList.list.find(slide => slide.index === index) !== undefined;\n        }\n      );\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach((slide: SlideWithIndex) => {\n      slide.item.active = true;\n    });\n  }\n\n  private isIndexOnTheEdges(index: number): boolean {\n    return (\n      index + 1 - this.itemsPerSlide <= 0 ||\n      index + this.itemsPerSlide <= this._slides.length\n    );\n  }\n\n  private isIndexInRange(index: number): boolean {\n    if (this.singleSlideOffset) {\n      const visibleIndexes = this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return (\n      index <= this.getLastVisibleIndex() &&\n      index >= this.getFirstVisibleIndex()\n    );\n  }\n\n  private hideSlides(): void {\n    this.slides.forEach((slide: SlideComponent) => slide.active = false);\n  }\n\n  private isVisibleSlideListLast(): boolean {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  private isVisibleSlideListFirst(): boolean {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  private moveSliderByOneItem(direction: Direction): void {\n    let firstVisibleIndex: number;\n    let lastVisibleIndex: number;\n    let indexToHide: number;\n    let indexToShow: number;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n\n      indexToHide = direction === Direction.NEXT\n        ? firstVisibleIndex\n        : lastVisibleIndex;\n\n      indexToShow = direction !== Direction.NEXT\n        ? firstVisibleIndex - 1\n        : !this.isLast(lastVisibleIndex)\n          ? lastVisibleIndex + 1 : 0;\n\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n        (slide: SlideWithIndex) => slide.item.active\n      );\n\n      this.makeSlidesConsistent(slidesToReorder);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      let displayedIndex: number;\n\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex)\n          ? 0\n          : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n        displayedIndex = this.isFirst(firstVisibleIndex)\n          ? this._slides.length - 1\n          : firstVisibleIndex - 1;\n\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this.slideRangeChange.emit(\n        this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index)\n      );\n    }\n  }\n\n  private makeSlidesConsistent = (slides: SlideWithIndex[]): void => {\n    slides.forEach((slide: SlideWithIndex, index: number) => slide.item.order = index);\n  }\n\n  private moveMultilist(direction: Direction): void {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT\n          ? this._currentVisibleSlidesIndex + 1\n          : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n            ? 0\n            : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n            ? this._chunkedSlides.length - 1\n            : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        (slide: SlideWithIndex) => slide.item.active = true\n      );\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  private getVisibleIndexes(): number[] {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex]\n        .map((slide: SlideWithIndex) => slide.index);\n    } else {\n      return this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n    }\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n\n    if (!this.multilist) {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist(): boolean {\n    return this.itemsPerSlide > 1;\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nexport function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nexport function chunkByNumber<T>(array: T[], size: number): T[][] {\n  const out = [];\n  const n = Math.ceil((array.length) / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(\n      0,\n      (i === n - 1) && size < array.length ? array.length : size\n    );\n\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n","import {\n  Component,\n  HostBinding,\n  OnDestroy,\n  Input,\n  OnInit\n} from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\n\n@Component({\n  selector: 'slide',\n  template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  host: {\n    '[attr.aria-hidden]': '!active'\n  },\n  styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n  `]\n})\nexport class SlideComponent implements OnInit, OnDestroy {\n  /** Is current slide active */\n  @HostBinding('class.active')\n  @Input()\n  active: boolean;\n\n  @HostBinding('style.width') itemWidth = '100%';\n  @HostBinding('style.order') order = 0;\n  @HostBinding('class.carousel-animation') isAnimated: boolean;\n\n  /** Wraps element by appropriate CSS classes */\n  @HostBinding('class.item')\n  @HostBinding('class.carousel-item')\n  addClass = true;\n\n  /** Link to Parent(container-collection) component */\n  protected carousel: CarouselComponent;\n\n  constructor(carousel: CarouselComponent) {\n    this.carousel = carousel;\n  }\n\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit(): void {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy(): void {\n    this.carousel.removeSlide(this);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [SlideComponent, CarouselComponent],\n  exports: [SlideComponent, CarouselComponent],\n  providers: [CarouselConfig]\n})\nexport class CarouselModule {\n  static forRoot(): ModuleWithProviders<CarouselModule> {\n    return { ngModule: CarouselModule, providers: [] };\n  }\n}\n"]}