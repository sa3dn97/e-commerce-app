(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('ngx-bootstrap/buttons', ['exports', '@angular/core', '@angular/forms'], factory) :
    (global = global || self, factory((global['ngx-bootstrap'] = global['ngx-bootstrap'] || {}, global['ngx-bootstrap'].buttons = {}), global.ng.core, global.ng.forms));
}(this, (function (exports, core, forms) { 'use strict';

    // tslint:disable:no-use-before-declare
    // TODO: config: activeClass - Class to apply to the checked buttons
    var CHECKBOX_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        /* tslint:disable-next-line: no-use-before-declare */
        useExisting: core.forwardRef(function () { return ButtonCheckboxDirective; }),
        multi: true
    };
    /**
     * Add checkbox functionality to any element
     */
    var ButtonCheckboxDirective = /** @class */ (function () {
        function ButtonCheckboxDirective() {
            /** Truthy value, will be set to ngModel */
            this.btnCheckboxTrue = true;
            /** Falsy value, will be set to ngModel */
            this.btnCheckboxFalse = false;
            this.state = false;
            this.onChange = Function.prototype;
            this.onTouched = Function.prototype;
        }
        // view -> model
        ButtonCheckboxDirective.prototype.onClick = function () {
            if (this.isDisabled) {
                return;
            }
            this.toggle(!this.state);
            this.onChange(this.value);
        };
        ButtonCheckboxDirective.prototype.ngOnInit = function () {
            this.toggle(this.trueValue === this.value);
        };
        Object.defineProperty(ButtonCheckboxDirective.prototype, "trueValue", {
            get: function () {
                return typeof this.btnCheckboxTrue !== 'undefined'
                    ? this.btnCheckboxTrue
                    : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonCheckboxDirective.prototype, "falseValue", {
            get: function () {
                return typeof this.btnCheckboxFalse !== 'undefined'
                    ? this.btnCheckboxFalse
                    : false;
            },
            enumerable: true,
            configurable: true
        });
        ButtonCheckboxDirective.prototype.toggle = function (state) {
            this.state = state;
            this.value = this.state ? this.trueValue : this.falseValue;
        };
        // ControlValueAccessor
        // model -> view
        ButtonCheckboxDirective.prototype.writeValue = function (value) {
            this.state = this.trueValue === value;
            this.value = value ? this.trueValue : this.falseValue;
        };
        ButtonCheckboxDirective.prototype.setDisabledState = function (isDisabled) {
            this.isDisabled = isDisabled;
        };
        ButtonCheckboxDirective.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        ButtonCheckboxDirective.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /** @nocollapse */ ButtonCheckboxDirective.ɵfac = function ButtonCheckboxDirective_Factory(t) { return new (t || ButtonCheckboxDirective)(); };
        /** @nocollapse */ ButtonCheckboxDirective.ɵdir = core["ɵɵdefineDirective"]({ type: ButtonCheckboxDirective, selectors: [["", "btnCheckbox", ""]], hostVars: 3, hostBindings: function ButtonCheckboxDirective_HostBindings(rf, ctx) { if (rf & 1) {
                core["ɵɵlistener"]("click", function ButtonCheckboxDirective_click_HostBindingHandler() { return ctx.onClick(); });
            } if (rf & 2) {
                core["ɵɵattribute"]("aria-pressed", ctx.state);
                core["ɵɵclassProp"]("active", ctx.state);
            } }, inputs: { btnCheckboxTrue: "btnCheckboxTrue", btnCheckboxFalse: "btnCheckboxFalse" }, features: [core["ɵɵProvidersFeature"]([CHECKBOX_CONTROL_VALUE_ACCESSOR])] });
        return ButtonCheckboxDirective;
    }());
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](ButtonCheckboxDirective, [{
            type: core.Directive,
            args: [{
                    selector: '[btnCheckbox]',
                    providers: [CHECKBOX_CONTROL_VALUE_ACCESSOR]
                }]
        }], null, { btnCheckboxTrue: [{
                type: core.Input
            }], btnCheckboxFalse: [{
                type: core.Input
            }], state: [{
                type: core.HostBinding,
                args: ['class.active']
            }, {
                type: core.HostBinding,
                args: ['attr.aria-pressed']
            }], onClick: [{
                type: core.HostListener,
                args: ['click']
            }] }); })();

    var RADIO_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        /* tslint:disable-next-line: no-use-before-declare */
        useExisting: core.forwardRef(function () { return ButtonRadioDirective; }),
        multi: true
    };
    /**
     * Create radio buttons or groups of buttons.
     * A value of a selected button is bound to a variable specified via ngModel.
     */
    var ButtonRadioDirective = /** @class */ (function () {
        function ButtonRadioDirective(el, cdr, group, renderer) {
            this.el = el;
            this.cdr = cdr;
            this.group = group;
            this.renderer = renderer;
            this.onChange = Function.prototype;
            this.onTouched = Function.prototype;
        }
        Object.defineProperty(ButtonRadioDirective.prototype, "value", {
            /** Current value of radio component or group */
            get: function () {
                return this.group ? this.group.value : this._value;
            },
            set: function (value) {
                if (this.group) {
                    this.group.value = value;
                    return;
                }
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonRadioDirective.prototype, "disabled", {
            /** If `true` — radio button is disabled */
            get: function () {
                return this._disabled;
            },
            set: function (disabled) {
                this._disabled = disabled;
                this.setDisabledState(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonRadioDirective.prototype, "isActive", {
            get: function () {
                return this.btnRadio === this.value;
            },
            enumerable: true,
            configurable: true
        });
        ButtonRadioDirective.prototype.onClick = function () {
            if (this.el.nativeElement.attributes.disabled || !this.uncheckable && this.btnRadio === this.value) {
                return;
            }
            this.value = this.uncheckable && this.btnRadio === this.value ? undefined : this.btnRadio;
            this._onChange(this.value);
        };
        ButtonRadioDirective.prototype.ngOnInit = function () {
            this.uncheckable = typeof this.uncheckable !== 'undefined';
        };
        ButtonRadioDirective.prototype.onBlur = function () {
            this.onTouched();
        };
        ButtonRadioDirective.prototype._onChange = function (value) {
            if (this.group) {
                this.group.onTouched();
                this.group.onChange(value);
                return;
            }
            this.onTouched();
            this.onChange(value);
        };
        // ControlValueAccessor
        // model -> view
        ButtonRadioDirective.prototype.writeValue = function (value) {
            this.value = value;
            this.cdr.markForCheck();
        };
        ButtonRadioDirective.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        ButtonRadioDirective.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        ButtonRadioDirective.prototype.setDisabledState = function (disabled) {
            if (disabled) {
                this.renderer.setAttribute(this.el.nativeElement, 'disabled', 'disabled');
                return;
            }
            this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
        };
        /** @nocollapse */ ButtonRadioDirective.ɵfac = function ButtonRadioDirective_Factory(t) { return new (t || ButtonRadioDirective)(core["ɵɵdirectiveInject"](core.ElementRef), core["ɵɵdirectiveInject"](core.ChangeDetectorRef), core["ɵɵdirectiveInject"](ButtonRadioGroupDirective, 8), core["ɵɵdirectiveInject"](core.Renderer2)); };
        /** @nocollapse */ ButtonRadioDirective.ɵdir = core["ɵɵdefineDirective"]({ type: ButtonRadioDirective, selectors: [["", "btnRadio", ""]], hostVars: 3, hostBindings: function ButtonRadioDirective_HostBindings(rf, ctx) { if (rf & 1) {
                core["ɵɵlistener"]("click", function ButtonRadioDirective_click_HostBindingHandler() { return ctx.onClick(); });
            } if (rf & 2) {
                core["ɵɵattribute"]("aria-pressed", ctx.isActive);
                core["ɵɵclassProp"]("active", ctx.isActive);
            } }, inputs: { btnRadio: "btnRadio", uncheckable: "uncheckable", value: "value", disabled: "disabled" }, features: [core["ɵɵProvidersFeature"]([RADIO_CONTROL_VALUE_ACCESSOR])] });
        return ButtonRadioDirective;
    }());
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](ButtonRadioDirective, [{
            type: core.Directive,
            args: [{
                    selector: '[btnRadio]',
                    providers: [RADIO_CONTROL_VALUE_ACCESSOR]
                }]
        }], function () { return [{ type: core.ElementRef }, { type: core.ChangeDetectorRef }, { type: ButtonRadioGroupDirective, decorators: [{
                    type: core.Optional
                }] }, { type: core.Renderer2 }]; }, { btnRadio: [{
                type: core.Input
            }], uncheckable: [{
                type: core.Input
            }], value: [{
                type: core.Input
            }], disabled: [{
                type: core.Input
            }], isActive: [{
                type: core.HostBinding,
                args: ['class.active']
            }, {
                type: core.HostBinding,
                args: ['attr.aria-pressed']
            }], onClick: [{
                type: core.HostListener,
                args: ['click']
            }] }); })();

    var RADIO_CONTROL_VALUE_ACCESSOR$1 = {
        provide: forms.NG_VALUE_ACCESSOR,
        /* tslint:disable-next-line: no-use-before-declare */
        useExisting: core.forwardRef(function () { return ButtonRadioGroupDirective; }),
        multi: true
    };
    /**
     * A group of radio buttons.
     * A value of a selected button is bound to a variable specified via ngModel.
     */
    var ButtonRadioGroupDirective = /** @class */ (function () {
        function ButtonRadioGroupDirective(cdr) {
            this.cdr = cdr;
            this.onChange = Function.prototype;
            this.onTouched = Function.prototype;
        }
        Object.defineProperty(ButtonRadioGroupDirective.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        ButtonRadioGroupDirective.prototype.writeValue = function (value) {
            this._value = value;
            this.cdr.markForCheck();
        };
        ButtonRadioGroupDirective.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        ButtonRadioGroupDirective.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        ButtonRadioGroupDirective.prototype.setDisabledState = function (disabled) {
            if (this.radioButtons) {
                this.radioButtons.forEach(function (buttons) {
                    buttons.setDisabledState(disabled);
                });
            }
        };
        /** @nocollapse */ ButtonRadioGroupDirective.ɵfac = function ButtonRadioGroupDirective_Factory(t) { return new (t || ButtonRadioGroupDirective)(core["ɵɵdirectiveInject"](core.ChangeDetectorRef)); };
        /** @nocollapse */ ButtonRadioGroupDirective.ɵdir = core["ɵɵdefineDirective"]({ type: ButtonRadioGroupDirective, selectors: [["", "btnRadioGroup", ""]], contentQueries: function ButtonRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
                core["ɵɵcontentQuery"](dirIndex, ButtonRadioDirective, false);
            } if (rf & 2) {
                var _t;
                core["ɵɵqueryRefresh"](_t = core["ɵɵloadQuery"]()) && (ctx.radioButtons = _t);
            } }, features: [core["ɵɵProvidersFeature"]([RADIO_CONTROL_VALUE_ACCESSOR$1])] });
        return ButtonRadioGroupDirective;
    }());
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](ButtonRadioGroupDirective, [{
            type: core.Directive,
            args: [{
                    selector: '[btnRadioGroup]',
                    providers: [RADIO_CONTROL_VALUE_ACCESSOR$1]
                }]
        }], function () { return [{ type: core.ChangeDetectorRef }]; }, { radioButtons: [{
                type: core.ContentChildren,
                args: [core.forwardRef(function () { return ButtonRadioDirective; })]
            }] }); })();

    var ButtonsModule = /** @class */ (function () {
        function ButtonsModule() {
        }
        ButtonsModule.forRoot = function () {
            return { ngModule: ButtonsModule, providers: [] };
        };
        /** @nocollapse */ ButtonsModule.ɵmod = core["ɵɵdefineNgModule"]({ type: ButtonsModule });
        /** @nocollapse */ ButtonsModule.ɵinj = core["ɵɵdefineInjector"]({ factory: function ButtonsModule_Factory(t) { return new (t || ButtonsModule)(); } });
        return ButtonsModule;
    }());
    (function () { (typeof ngJitMode === "undefined" || ngJitMode) && core["ɵɵsetNgModuleScope"](ButtonsModule, { declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective], exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective] }); })();
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](ButtonsModule, [{
            type: core.NgModule,
            args: [{
                    declarations: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective],
                    exports: [ButtonCheckboxDirective, ButtonRadioDirective, ButtonRadioGroupDirective]
                }]
        }], null, null); })();

    exports.ButtonCheckboxDirective = ButtonCheckboxDirective;
    exports.ButtonRadioDirective = ButtonRadioDirective;
    exports.ButtonRadioGroupDirective = ButtonRadioGroupDirective;
    exports.ButtonsModule = ButtonsModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-bootstrap-buttons.umd.js.map
